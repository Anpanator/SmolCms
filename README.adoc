= SmolCms

This is a learning project for me using PHP8. Since I haven't decided on a license yet, I don't accept contributions at the moment.
If you want to use any code you'll have to ask for permission for the same reason.

== Configuring services

Check the `ServiceConfiguration` class.
For now, it's just hard-coded in the constructor.
Configuration of a new service is only necessary if:

* You need multiple instances
* You have scalar dependencies

If you manually configure a service, and it depends on another service that does *not* have a service configuration, you can set the fully qualified classname of the service instead (e.g. `MyService::class`).
If you have a service definition, you can set the identifier of the service you want to inject.
The `parameters` array needs to have the same order as the constructor parameters.

The `class` parameter can be omitted if the identifier is the fully qualified class name.

== Routing

You can define routes in the `RoutingConfiguration` class, similar to the service configuration.

Controllers are treated like services.
So in the simplest case, you use the fully qualified classname for the controller, e.g. `MyController::class`.
Alternatively, you can use the controllers service identifier.

Routes can contain path parameters in the form of `/some/path/with/{parameter}`.
Every path parameter must exist in the handler function with the same name (either untyped, mixed or type string, which is recommended).

A handler *must* also have a `$request` parameter.
The order of all these parameters is irrelevant.
If the handler configuration is omitted, the handler name is assumed to be `HTTP Method + 'Action'`, e.g. `getAction`, `postAction`, etc.

So with the example path above and a POST request, you'd need a handler method like this:

[source,php]
----
class SomeController {
    public function postAction(Request $request, string $parameter): Response
    {
        // ...
    }
}
----

== Validation

For validation on object properties, the generic `Validator` service can be used.
The object to validate is simply passed into its `validate()` method.
For validation to work, you will need to add attributes implementing the `PropertyValidationAttribute` interface on the object properties (multiple are supported).
If you want to have nested object validation, simply add the `ValidateObject` attribute to the property.

Usage:

[source,php]
----
class Foo {
    public function __construct(
    #[ValidateRange(min: 10, max: 100)]
    private float $floatVal,
    #[ValidateRange(min: -10, max: 0)]
    private int $intVal,
    #[ValidateAllowList(['ALLOWED', 1, true])]
    private mixed $mixedAllow,
    #[ValidateDenyList(['DENIED', 'ALSO_DENIED'])]
    private string $stringDeny,
) {
}
}

$foo = new Foo(
    floatVal: 15.0,
    intVal: -1,
    mixedAllow: 'ALLOWED',
    stringDeny: 'Not denied'
);
$result = $validator->validate($foo);
var_dump($result);
----

To support a new validation attribute, you only need to create it and have it implement the `PropertyValidationAttribute` interface.
The validator will then use it automatically.

== Testing

For ease of testing, the `Mock` attribute, `SimpleTestCase` and `FunctionalTestCase` classes have been introduced.

The `setUp()` method will automatically put an unconfigured test double into the property you use the `Mock` attribute on.

Usage:

[source,php]
----
class ServiceBuilderTest extends SimpleTestCase
{
    private ServiceBuilder $serviceBuilder;
    #[Mock(ServiceConfiguration::class)]
    private ServiceConfiguration|MockObject $serviceConfiguration;
    #[Mock(ServiceRegistry::class)]
    private ServiceRegistry|MockObject $serviceRegistry;
//...
}
----

Note: The property type hinting is not necessary and just used for convenient auto completion.

Additionally, the `FunctionalTestCase` class will provide an `ApplicationCore` that will allow you to simulate requests even without a web server.
This is useful when you want to create automated tests for JSON api endpoints for instance.